\documentclass[notes]{beamer}
%\documentclass[handout]{beamer}

\include{base}

\title{CUCaTS Python Workshop - Session 2}
\date{Lent 2015}

\begin{document}
	\begin{frame}[fragile]
		\maketitle
	\end{frame}
	
	% no particular order
	
	\begin{frame}[fragile]
		\frametitle{Logical operators}
		\begin{itemize}
			\item Act on booleans
			\item Allow you to chain together expressions
			\pause
			\item \lstinline|and|: returns \lstinline|True| if both of the operands are \lstinline|True|, otherwise returns \lstinline|False|.
			\item \lstinline|or|: returns \lstinline|True| if at least one of the operands is \lstinline|True|, otherwise returns \lstinline|False|.
			\item \lstinline|not|: returns the complement of the operand.
		\end{itemize}
	\end{frame}

	\begin{frame}[fragile]
		\frametitle{Try it out!}

		Print a number if it is divisible by two or three:

		\begin{lstlisting}
		>>> for num in range(10):
		...     if num % 2 == 0 or num % 3 == 0:
		...         print(num)
		\end{lstlisting}

		Print a number if it is divisible by three but not five:

		\begin{lstlisting}
		>>> for num in range(20):
		...     if num % 3 == 0 and not num % 5 == 0:
		...         print(num)
		\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]
		\frametitle{Slicing}

		\begin{itemize}
			\item Take a section of a string or list:
			\begin{lstlisting}[xleftmargin=\dimexpr-\leftmargini]
			>>> name = "Satyarth"
			>>> nickname = name[0:3]$\pause$
			>>> nickname
			"Sat"
			\end{lstlisting}

			\item \lstinline|[$\colorbox{lightspacebg}{\rule{0pt}{6pt}start}$:$\colorbox{lightspacebg}{end}$]| \\
			means ``from \lstinline|start|, up to (but not including) \lstinline|end|".
			
			\item View the indices as between the elements:
		\end{itemize}
		\begin{tabular}{llllllllllllllllll}
			~ & \color{red}\tt S & ~ & \color{red}\tt a & ~ & \color{red}\tt t & ~ & \color{red}\tt y & ~ & \color{red}\tt a & ~ & \color{red}\tt r & ~ & \color{red}\tt t & ~ & \color{red}\tt h \\
			0 & ~ & 1 & ~ & 2 & ~ & 3 & ~ & 4 & ~ & 5 & ~ & 6 & ~ & 7 & ~ & 8 \\
		\end{tabular}
	\end{frame}
		
	\begin{frame}[fragile]
		\frametitle{Slicing}
		
		\begin{itemize}
			\item \lstinline|start| and \lstinline|end| are optional:
			\begin{columns}[c]
				\column{.45\textwidth}
				\begin{lstlisting}
				>>> "Satyarth"[:3]
				"Sat"
				\end{lstlisting}
				\column{.45\textwidth}
				\begin{lstlisting}
				>>> "Satyarth"[3:]
				"yarth"
				\end{lstlisting}
			\end{columns}
			\note<3>{This is another reason why the end is not included: if it was, ``y" would have appeared in both slices.}
			
			\pause
			
			\item This leads to an idiom for duplicating a list or string:
			\begin{lstlisting}[xleftmargin=\dimexpr-\leftmargini]
			>>> original = [1, 2, 3]
			>>> dup = original[:]
			>>> dup.append(5)
			>>> original, dup
			[1, 2, 3], [1, 2, 3, 5]
			\end{lstlisting}
			
			\pause
			
			\item Third option: step size.
			
			\begin{columns}[c]
				\column{.45\textwidth}
				\begin{lstlisting}
				>>> "Satyarth"[1::2]
				"ayrh"
				\end{lstlisting}
				\column{.45\textwidth}
				\begin{lstlisting}
				>>> "Satyarth"[::-1]
				"htraytaS"
				\end{lstlisting}
			\end{columns}
		\end{itemize}
		
		% x:y, optional (off by one), step
		% why is the end not included? give a good reason
		% - ensures len of result == y-x
		% - x[0:len(x)] shouldn't be a bounds error (would be otherwise)
		%   - i think that last one highlights it: indices are cardinal, not ordinal, numbers
	\end{frame}
	
	\begin{frame}[fragile]
		\frametitle{List comprehensions}
		% if predicate, filtering
	\end{frame}
	
	\begin{frame}[fragile]
		\frametitle{Dictionaries}
		
		\begin{itemize}
			\item Dictionaries allow us to have a bunch of \evenbox{jargonbg}{values} associated with certain \evenbox{jargonbg}{keys}.
			\begin{lstlisting}[xleftmargin=\dimexpr-\leftmargini]
			ages = {"Alice": 42, "Bob": 40}
			\end{lstlisting}
			
			\item One ``looks up" the key and gets the value back.
			\begin{lstlisting}[xleftmargin=\dimexpr-\leftmargini]
			>>> ages["Bob"]
			40\end{lstlisting}
			
			\item Jargon: \lstinline|"Alice"| is said to \evenbox{jargonbg}{map} to \lstinline|42|.
			
			% datatypes that can be used as keys? hashable, immutable
			% strings, floats, integers, tuples (mention?)
			% keys and values do not have to be of one type
		\end{itemize}
		
		Keys:
		\begin{lstlisting}[xleftmargin=\dimexpr-\leftmargini]
		>>> ages.keys()
		dict_keys(['Alice', 'Bob'])\end{lstlisting}
		Adding or changing items:
		\begin{lstlisting}[xleftmargin=\dimexpr-\leftmargini]
		>>> ages.update({"Charlie": 1})\end{lstlisting}
	\end{frame}
	
	\begin{frame}[fragile]
		\frametitle{Values and Variables}
		Remember:
		\begin{itemize}
			\item Values are pieces of data stored in computer memory.
			\item Variables are labels put onto values.
		\end{itemize}
		
		\pause
		
		\begin{lstlisting}
		>>> x = [7, 8]
		>>> y = x
		>>> y.append(11)
		>>> x
		$\pause$[7, 8, 11]
		\end{lstlisting}
		
		Result:
		\begin{itemize}
			\item Assignment does not create a new value.
			\item More than one variable can label the same value.
			% use the words aliasing, reference?
		\end{itemize}
	\end{frame}
	
	\begin{frame}[fragile]
		\frametitle{}
		% duck typing
	\end{frame}
	
	\begin{frame}[fragile]
		\frametitle{while}
		\begin{itemize}
			\item Sometimes you want your loop to run while some condition is met, as opposed to a set number of times (\lstinline|for| loops).
			\item Enter the \lstinline|while| loop.
			\pause
			\item Example:
			\begin{lstlisting}
			>>> num = 0
			>>> while num % 3 != 0:
			...     n = input("Enter a number: ")
			\end{lstlisting}

		\end{itemize}
	\end{frame}
	
	\begin{frame}[fragile]
		\frametitle{break and continue}
		% motivating example?
	\end{frame}
	
	\begin{frame}[fragile]
		\frametitle{Tuples}
		% unpacking (assignment, for)
	\end{frame}
	
	\begin{frame}[fragile]
		\frametitle{Files}
		% use with, damn nice syntax
	\end{frame}
\end{document}